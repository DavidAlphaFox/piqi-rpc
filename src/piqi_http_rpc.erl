%% Copyright 2009, 2010, 2011 Anton Lavrik
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.

-module(piqi_http_rpc).

-compile(export_all).


-include_lib("webmachine/include/webmachine.hrl").


%
% Webmachine callbacks
%


-record(context, {
    skel_mod,   % Piqi-RPC skeleton module generated by piqic-erlang-rpc
    impl_mod    % Piqi-RPC implementation module containing callback functions
}).


init([SkelMod, ImplMod]) ->
    Context = #context{
        skel_mod = SkelMod,
        impl_mod = ImplMod
    },
    {ok, Context}.


allowed_methods(ReqData, Context) ->
    Methods =
        case wrq:disp_path(ReqData) of
            "" -> ['GET']; % get_piqi
            "/" -> ['GET']; % XXX: another way of getting Piqi
            _ ->
                % TODO: check function name -- at the very least it
                % shouldn't contain "/" characters
                ['POST']
        end,
    % otherwise, return 405 Method not allowed
    {Methods, ReqData, Context}.


known_content_type(ReqData, Context) ->
    IsKnownType =
        case wrq:get_req_header("content-type", ReqData) of
            "application/json" -> true;
            % XXX: or use "application/octet-stream" instead?
            "application/protobuf" -> true;
            _ -> false
        end,
    % otherwise, return 415 Unsupported media type
    {IsKnownType, ReqData, Context}.


% called for GET request
content_types_provided(ReqData, Context) ->
    % for all other types 406 Not Acceptable will be returned
    ContentTypes = [
        % XXX: or use "application/octet-stream" instead?
        {"application/protobuf", get_piqi_pb}
        % TODO:
        %{"application/json", get_piqi_json}
    ],
    {ContentTypes, ReqData, Context}.


% called for POST request
content_types_accepted(ReqData, Context) ->
    % for all other types 415 Unsupported media type will be returned
    ContentTypes = [
        % XXX: or use "application/octet-stream" instead?
        {"application/protobuf", rpc_pb},
        {"application/json", rpc_json}
    ],
    {ContentTypes, ReqData, Context}.


format_to_content_type('pb') ->
    "application/protobuf";
format_to_content_type('json') ->
    "application/json".


malformed_request(ReqData, Context) ->
    % XXX, NOTE: this check is actually not necessary, havign a query string
    % doesn't affect anything
    IsMalformed =
        case wrq:req_qs(ReqData) of
            "" ->
                NewReqData = ReqData,
                false;
            _ ->
                NewReqData = wrq:set_resp_body(ReqData, <<"empty query string expected">>),
                true  % return 400 Bad request
        end,
    {IsMalformed, NewReqData, Context}.


%
% Main RPC method handlers
%

get_piqi_pb(ReqData, Context) ->
    SkelMod = Context#context.skel_mod,
    Body = SkelMod:get_piqi(),
    {Body, ReqData, Context}.


rpc_pb(ReqData, Context) ->
    rpc(ReqData, Context, pb).


rpc_json(ReqData, Context) ->
    rpc(ReqData, Context, json).


rpc(ReqData, Context, InputFormat) ->
    FuncName = list_to_binary(wrq:disp_path(ReqData)),
    InputData = wrq:req_body(ReqData),
    % TODO: determine output format from "Accept" header
    OutputFormat = InputFormat,

    SkelMod = Context#context.skel_mod,
    ImplMod = Context#context.impl_mod,

    % make the actual call
    RpcResponse = SkelMod:rpc(ImplMod, FuncName, InputData, InputFormat, OutputFormat),

    case RpcResponse of
        ok ->
            % return empty 200 OK
            {true, ReqData, Context};

        {ok, OutputData} ->
            NewReqData = wrq:set_resp_body(OutputData, ReqData),
            % return 200 OK
            {true, NewReqData, Context};

        {error, ErrorData} -> % application error
            NewReqData = wrq:set_resp_header(
                "Content-Type",
                format_to_content_type(OutputFormat),
                ReqData),
            % return 500 "Internal Server Error" with the structured error
            % desciption formatted according to the desired output format
            %
            % NOTE, XXX: {error, } and {'prc_error', {'internal_error', _}} use
            % the same 500 HTTP status code. The the only difference between
            % them is the "Content-Type" header which is set to "text/plain" in
            % the latter case.
            {{error, ErrorData}, NewReqData, Context};

        % input-related errors:
        {'rpc_error', 'unknown_function'} ->
            % return 404 "Not Found"
            {{halt, 404}, ReqData, Context};

        {'rpc_error', 'missing_input'} ->
            % return 411 "Length required"
            {{halt, 411}, ReqData, Context};

        {'rpc_error', {'invalid_input', Err}} ->
            % return 400 "Bad Request"
            NewReqData = set_string_error(Err, ReqData),
            {{halt, 400}, NewReqData, Context};

        % other errors:
        {'rpc_error', {'invalid_output', Err}} ->
            % return 502 "Bad Gateway"
            NewReqData = set_string_error(Err, ReqData),
            {{halt, 502}, NewReqData, Context};

        {'rpc_error', {'internal_error', Err}} ->
            % return 500 "Internal Server Error" NOTE: using the same status
            % code as for application error, but different Content-Type. See the
            % "{error, _}" case for the details.
            NewReqData = set_string_error(Err, ReqData),
            % XXX: use halt for this one as well?
            {error, NewReqData, Context}

        % NOTE: Piqi-RPC over HTTP never generates this one as protocol
        % validations is taken care of by the HTTP server
        %{'rpc_error', {'protocol_error', Err}}
  end.


set_string_error(Str, ReqData) when is_binary(Str) ->
    wrq:set_resp_header("Content-Type", "test/plain",
        wrq:set_resp_body(Str, ReqData));

set_string_error(Str, ReqData) when is_list(Str) ->
    set_string_error(list_to_binary(Str), ReqData).

